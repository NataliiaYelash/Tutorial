// РОЗГАЛУЖЕННЯ


// if (умова) { тіло if } 
//Якщо умова приводиться до true, то виконується код у фігурних дужках тіла if
// let cost = 0;
// const subscription = "pro";

// if (subscription === "pro") {
//     cost = 100;
// }
// console.log(cost);//100

// Якщо умова приводиться до false, код у фігурних дужках буде пропущений
// let cost = 0;
// const subscription = "free";

// if (subscription === "pro") {
//   cost = 100;
// }
// console.log(cost);//0


// if...else - може перевірити і зреагувати на виконання або невиконання лише однієї умови
// if (умова) {// тіло if
// } else {// тіло else
// }

// якщо умова приводиться до false, виконається код у фігурних дужках після оператора else
// let cost;
// const subscription = "free";

// if (subscription === "pro") {
//   cost = 100;
// } else {
//   cost = 0;
// }
// console.log(cost);//0

// Якщо умова приводиться до true, тіло блока else ігнорується
// let cost;
// const subscription = "pro";

// if (subscription === "pro") {
//   cost = 100;
// } else {
//   cost = 0;
// }
// console.log(cost); // 100


// else...if - дозволяє додати після else ще один оператор if з умовою. В кінці ланцюжка може бути класичний блок else, який виконається лише у тому випадку, якщо жодна умова не приведеться до true
// При першому true перевірки припиняться і виконається лише один сценарій, який відповідає цьому true. Тому, такий запис варто читати як: шукаю перший збіг умови, ігнорую все інше.
// let cost;
// const subscription = "premium";

// if (subscription === "free") {
//   cost = 0;
// } else if (subscription === "pro") {
//   cost = 100;
// } else if (subscription === "premium") {
//   cost = 500;
// } else {
//   console.log("Invalid subscription type");
// }
// console.log(cost);


// ТЕРНАРНИЙ ОПЕРАТОР
// використовується у якості синтаксично коротшої заміни інструкції if...else, коли одній і тій самій змінній необхідно присвоїти різні значення за умовою.
//<умова> ? <вираз_якщо_умова_правдива> : <вираз_якщо_умова_хибна>
// let type;
// const age = 20;

// if (age >= 18) {
//   type = "adult";
// } else {
//   type = "child";
// }
// console.log(type); // "adult"

//Виконаємо рефакторинг, замінивши if...else на тернарний оператор.
// const age = 20;
// const type = age >= 18 ? "adult" : "child";
// console.log(type); // "adult"

//Запишемо операцію пошуку більшого числа.
// const num1 = 5;
// const num2 = 10;
// let biggerNumber;

// if (num1 > num2) {
//   biggerNumber = num1;
// } else {
//   biggerNumber = num2;
// }
// console.log(biggerNumber); // 10
//Код працює правильно, отримуємо більше число з двох, але це рішення здається занадто громіздким, враховуючи, наскільки проста проблема. Використовуємо тернарний оператор.
// const num1 = 5;
// const num2 = 10;
// const biggerNumber = num1 > num2 ? num1 : num2;
// console.log(biggerNumber); // 10


//SWITCH   - складається із блоку switch(значення) - що потрібно порівняти і набору окремих випадків case значення - з чим потрібно порівняти.

// switch (значення) {
//     case значення:
//       інструкції;
//       break;

//     case значення:
//       інструкції;
//       break;

//     default:
//       інструкції;
//   }

//Оператор break в кінці кожного блоку case необхідний, щоб перервати подальші перевірки і одразу перейти до коду за switch у тому випадку, коли перевірка рівності повернула true

// let cost;
// const subscription = "premium";

// switch (subscription) {
//   case "free":
//     cost = 0;
//     break;

//   case "pro":
//     cost = 100;
//     break;

//   case "premium":
//     cost = 500;
//     break;

//   default:
//     console.log("Invalid subscription type");
// }

// console.log(cost); // 500

//Якщо оператор break відсутній, то після того як виконається будь-яка умова case, усі наступні за ним блоки коду будуть виконуватися один за одним, що може призвести до небажаних наслідків у випадку неправильного застосування.



//ОБЛАСТЬ ВИДИМОСТІ
//змінна value оголошена у глобальній області видимості, тобто поза будь-яким блоком, і доступна в будь-якому місці після оголошення
// const value = 5;
// if (true) {
//   console.log("Block scope: ", value); // 5
// }
// console.log("Global scope: ", value); // 5

//Будь-яка конструкція, яка використовує фігурні дужки {} (умови, цикли, функції тощо), створює нову локальну область видимості, і змінні, оголошені в цій області видимості, з використанням let або const, - недоступні за межами цього блоку.
// if (true) {
//     const values = 5;
//     console.log("Block scope: ", values); // 5
//   } 
//   console.log("Global scope: ", values); // ReferenceError: value is not defined



//ЦИКЛИ

//while - цикл, який виконується, доки правдива якась умова, зазначена до його початку. Ця умова перевіряється до виконання тіла циклу, тому тіло може не виконатися жодного разу, якщо умова від самого початку - хибна
// while (condition) { // код, тіло циклу (statement) }
// Конструкція while створює цикл, який виконує блок коду, доки умова перевірки оцінюється як true.

// condition, тобто умова, оцінюється перед кожною ітерацією циклу.
// Якщо condition оцінюється як true, оператор while виконує statement.
// Якщо condition оцінюється як false, виконання циклу переривається і скрипт продовжує виконувати інструкції після циклу while
//Створимо лічильник.
// let counter = 0;
// while (counter < 10) {
//   console.log("counter: ", counter);
//   counter += 1;
// }

//Будемо заповнювати місця в готелі доти, доки поточна кількість клієнтів не буде дорівнювати максимально можливій.
// let clientCounter = 18;
// const maxClients = 25;
// while (clientCounter < maxClients) {
//   console.log(clientCounter);
//   clientCounter += 1;
// }

//do...while - цикл, в якому умова перевіряється після виконання тіла циклу. З цього випливає, що тіло завжди виконується хоча б один раз

// Конструкція do...while створює цикл, який виконує блок коду доти, доки condition не поверне false.

// На відміну від циклу while, цикл do...while завжди виконує statement мінімум один раз, перш ніж він оцінить condition.

// Всередині циклу потрібно внести зміни в деяку змінну, щоб переконатися, що вираз дорівнює false після ітерацій. Інакше буде нескінченний цикл
// let password = "";
// do {
//   password = prompt("Введіть пароль довший 4-х символів", "");
// } while (password.length < 5);
// console.log("Ввели пароль: ", password);

//for - цикл, в якому певна змінна змінює своє значення із заданого початкового до кінцевого значення з деяким кроком, і для кожного значення цієї змінної тіло циклу виконується один раз.
//В більшості процедурних мов програмування реалізується конструкцією for, в якій зазначається лічильник, необхідна кількість ітерацій і крок, з яким змінюється лічильник.

// for (initialization; condition; post-expression) {
  // statements
//   }

//Змінні-лічильники, за традицією, називаються літерами i, j і k
// for (let i = 0; i <= 20; i += 5) {
//    console.log(i);
//   }

//У прикладі оголошується змінна-лічильник i, ініціалізується значенням 0 і цикл виконується доти, доки i <= 20, тобто умова приводиться до true. Після кожної ітерації лічильник збільшується на 5.

//Порахуємо суму чисел до певного значення.
// const target = 3;
// let sum = 0;
// for (let i = 0; i <= target; i += 1) {
//   sum += i;
// }
// console.log(sum);

//Згадаємо про операцію a % b і виведемо остачу від ділення за допомогою циклу.
// const max = 10;
// for (let i = 0; i < max; i += 1) {
//   console.log(`${max} % ${i} = `, max % i);
// }

// оператор break - повністю припиняє виконання циклу і передає управління на рядок після його тіла
//Знайдемо число 3. Щойно виконається умова if, цикл припинить своє виконання (буде перерваний).
// for (let i = 0; i <= 5; i += 1) {
//     console.log(i);
//     if (i === 3) {
//       console.log("Знайшли число 3, перериваємо виконання циклу");
//       break;
//     }
//   }
//   console.log("Лог після циклу");

//Оператор continue - Перериває не увесь цикл, а тільки виконання поточної ітерації. Його використовують, якщо зрозуміло, що на поточній ітерації циклу більше немає що робити або взагалі не потрібно нічого робити, і час переходити до наступної ітерації.
//Використовуємо цикл для введення тільки непарних чисел. Для парних i спрацьовує continue, виконання тіла припиняється і управління передається до наступної ітерації
// const number = 10;
// for (let i = 0; i < number; i += 1) {
//   if (i % 2 === 0) {
//     continue;
//   }
//   console.log("Непарне i: ", i); // 1, 3, 5, 7, 9
// }















